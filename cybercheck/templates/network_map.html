{% extends "layout.html" %}

{% block body %}
<div class="page-header">
  <div>
    <h1 class="h2 mb-2">Network map</h1>
    <p class="page-subtitle mb-0">Generate a relationship map from live packet captures to understand which systems are talking to each other. Keep the page open to watch the topology settle as new flows appear.</p>
  </div>
  <div class="text-end small text-muted2" id="topologyStatus"></div>
</div>

<div class="row g-4" id="topologySummary">
  <div class="col-lg-3 col-sm-6">
    <div class="metric-card">
      <span class="metric-label">Observed hosts</span>
      <span class="metric-value" data-field="nodes">—</span>
      <span class="metric-subtext">Active in the {{ window_seconds }}s window</span>
    </div>
  </div>
  <div class="col-lg-3 col-sm-6">
    <div class="metric-card">
      <span class="metric-label">Connections</span>
      <span class="metric-value" data-field="links">—</span>
      <span class="metric-subtext">Unique src → dst edges</span>
    </div>
  </div>
  <div class="col-lg-3 col-sm-6">
    <div class="metric-card">
      <span class="metric-label">Packets in window</span>
      <span class="metric-value" data-field="packets">—</span>
      <span class="metric-subtext">Used to build the graph</span>
    </div>
  </div>
  <div class="col-lg-3 col-sm-6">
    <div class="metric-card">
      <span class="metric-label">Monitor uptime</span>
      <span class="metric-value" data-field="uptime">—</span>
      <span class="metric-subtext">Since live capture started</span>
    </div>
  </div>
</div>

<div class="row g-4 mt-1">
  <div class="col-xl-8">
    <div class="card shadow-sm border-0 h-100">
      <div class="card-header bg-white border-0 pt-4 pb-3 d-flex justify-content-between align-items-center flex-wrap gap-3">
        <h2 class="h5 mb-0">Topology canvas</h2>
        <div class="d-flex align-items-center gap-3 flex-wrap">
          <div class="d-flex align-items-center gap-2">
            <label for="interfaceSelect" class="form-label mb-0 small text-muted2">Interface</label>
            <select id="interfaceSelect" class="form-select form-select-sm" style="min-width: 180px;"></select>
          </div>
          <button id="resetTopologyBtn" type="button" class="btn btn-outline-danger btn-sm">Reset map</button>
          <div class="topology-legend" aria-label="Legend">
            <span class="legend-pill local">Local</span>
            <span class="legend-pill private">Private</span>
            <span class="legend-pill public">Public</span>
            <span class="legend-pill unknown">Unknown</span>
          </div>
        </div>
      </div>
      <div class="card-body">
        <div class="topology-canvas" id="topologyCanvas" role="img" aria-label="Network relationships"></div>
        <p class="text-muted2 small mb-0">Edges are sized by packet volume; drag nodes to pin interesting systems and watch new flows settle into the map.</p>
      </div>
    </div>
  </div>
  <div class="col-xl-4">
    <div class="card shadow-sm border-0 h-100">
      <div class="card-header bg-white border-0 pt-4 pb-3">
        <h2 class="h5 mb-0">Connection details</h2>
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-sm align-middle monitor-table">
            <thead>
              <tr>
                <th scope="col">Source</th>
                <th scope="col">Destination</th>
                <th scope="col" class="text-end">Packets</th>
              </tr>
            </thead>
            <tbody id="connectionTable"></tbody>
          </table>
        </div>
        <p class="text-muted2 small mb-0">Table updates alongside the graph so you can quickly trace who is talking to whom.</p>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>
<script>
  (() => {
    const statusEl = document.getElementById('topologyStatus');
    const canvas = document.getElementById('topologyCanvas');
    const tableBody = document.getElementById('connectionTable');
    const summary = document.getElementById('topologySummary');
    const ifaceSelect = document.getElementById('interfaceSelect');

    const width = canvas.clientWidth || 720;
    const height = 640;

    const svg = d3.select(canvas)
      .append('svg')
      .attr('viewBox', `0 0 ${width} ${height}`)
      .attr('preserveAspectRatio', 'xMidYMid meet');

    // --- Persistent layers & state ---
    const zoomLayer  = svg.append('g');
    const linkLayer  = zoomLayer.append('g')
      .attr('stroke', '#cbd5e1')
      .attr('stroke-opacity', 0.5);
    const nodeLayer  = zoomLayer.append('g');
    const labelLayer = zoomLayer.append('g');

    let nodes = [];
    let links = [];

    let nodeSel  = nodeLayer.selectAll('circle');
    let linkSel  = linkLayer.selectAll('line');
    let labelSel = labelLayer.selectAll('g');

    let simulation;
    let linkForce;

    // Track seen node IDs so we know when something is *new*
    let knownNodeIds = new Set();

    // Zoom stays the same across updates
    svg.call(
      d3.zoom()
        .scaleExtent([0.5, 3])
        .on('zoom', (event) => {
          zoomLayer.attr('transform', event.transform);
        })
    );

    // Create a single simulation that we reuse
    simulation = d3.forceSimulation(nodes)
      .force('link', (linkForce = d3.forceLink(links)
        .id(d => d.id)
        .distance(90)
        .strength(0.6)))
      .force('charge', d3.forceManyBody().strength(-220))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .on('tick', () => {
        linkSel
          .attr('x1', d => d.source.x)
          .attr('y1', d => d.source.y)
          .attr('x2', d => d.target.x)
          .attr('y2', d => d.target.y);

        nodeSel
          .attr('cx', d => d.x)
          .attr('cy', d => d.y);

        labelSel
          .attr('transform', d => `translate(${d.x},${d.y})`);
      });

    const formatNumber = (value) => {
      if (value === null || value === undefined) return '—';
      if (value > 1_000_000) return `${(value / 1_000_000).toFixed(1)}M`;
      if (value > 1_000) return `${(value / 1_000).toFixed(1)}k`;
      return value.toString();
    };

    const formatUptime = (seconds) => {
      if (!seconds || seconds < 0) return '—';
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      const parts = [];
      if (hours) parts.push(`${hours}h`);
      if (minutes) parts.push(`${minutes}m`);
      if (!hours && !minutes) parts.push(`${secs}s`);
      return parts.join(' ');
    };

    const updateSummary = (data) => {
      summary.querySelector('[data-field="nodes"]').textContent = formatNumber(data.nodes?.length || 0);
      summary.querySelector('[data-field="links"]').textContent = formatNumber(data.links?.length || 0);
      summary.querySelector('[data-field="packets"]').textContent = formatNumber(data.metadata?.packets_in_window || 0);
      summary.querySelector('[data-field="uptime"]').textContent = formatUptime(data.metadata?.uptime);
    };

    const colorForRole = (role) => {
      switch (role) {
        case 'local': return '#2563eb';
        case 'private': return '#16a34a';
        case 'public': return '#e11d48';
        default: return '#6b7280';
      }
    };

    const renderTable = (links) => {
      tableBody.innerHTML = '';
      (links || []).slice(0, 25).forEach(link => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td><span class="mono">${link.source}</span></td>
          <td><span class="mono">${link.target}</span></td>
          <td class="text-end fw-semibold">${formatNumber(link.packets || 0)}</td>
        `;
        tableBody.appendChild(row);
      });
    };

    const linkKey = (d) => {
      const s = typeof d.source === 'object' ? d.source.id : d.source;
      const t = typeof d.target === 'object' ? d.target.id : d.target;
      return `${s}->${t}`;
    };

    const renderGraph = (topology) => {
      const incomingNodes = topology.nodes || [];
      const incomingLinks = topology.links || [];

      const incomingIds = new Set(incomingNodes.map(n => n.id));

      // Drop any nodes that disappeared from the latest topology snapshot
      nodes = nodes.filter(n => incomingIds.has(n.id));

      // Existing nodes by id so we can reuse positions
      const existingById = new Map(nodes.map(n => [n.id, n]));

      // Update existing nodes or add new ones, never removing previously seen nodes
      incomingNodes.forEach(n => {
        const existing = existingById.get(n.id);
        knownNodeIds.add(n.id);
        if (existing) {
          existing.label    = n.label;
          existing.hostname = n.hostname;
          existing.role     = n.role;
          existing.packets  = n.packets;
        } else {
          const nn = { ...n };
          nodes.push(nn);
          existingById.set(n.id, nn);
        }
      });

      // Update or append links while preserving existing ones so the map only grows
      const linkByKey = new Map(links.map(l => [linkKey(l), l]));

      incomingLinks.forEach(l => {
        const key = linkKey(l);
        const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
        const targetId = typeof l.target === 'object' ? l.target.id : l.target;

        const sourceNode = existingById.get(sourceId) || { id: sourceId };
        const targetNode = existingById.get(targetId) || { id: targetId };

        const existing = linkByKey.get(key);
        if (existing) {
          existing.packets = l.packets;
          existing.source = sourceNode;
          existing.target = targetNode;
        } else {
          links.push({ ...l, source: sourceNode, target: targetNode });
        }
      });

      // ----- Links join -----
      linkSel = linkSel
        .data(links, linkKey);

      linkSel.exit().remove();

      const linkEnter = linkSel.enter()
        .append('line')
        .attr('stroke-width', d => Math.max(1.5, Math.log1p(d.packets || 1)));

      linkSel = linkEnter.merge(linkSel);

      // ----- Nodes join -----
      nodeSel = nodeSel
        .data(nodes, d => d.id);

      nodeSel.exit().remove();

      const nodeEnter = nodeSel.enter()
        .append('circle')
        .attr('r', d => Math.max(8, Math.log1p((d.packets || 6) * 2)))
        .attr('fill', d => colorForRole(d.role))
        .attr('stroke', '#0f172a')
        .attr('stroke-width', 1.5)
        .call(d3.drag()
          .on('start', (event, d) => {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          })
          .on('drag', (event, d) => {
            d.fx = event.x;
            d.fy = event.y;
          })
          .on('end', (event, d) => {
            if (!event.active) simulation.alphaTarget(0);
          })
        );

      nodeEnter.append('title')
        .text(d => `${d.label} (${d.role})`);

      nodeSel = nodeEnter.merge(nodeSel);

      // ----- Labels join -----
      labelSel = labelSel
        .data(nodes, d => d.id);

      labelSel.exit().remove();

      const labelEnter = labelSel.enter()
        .append('g')
        .attr('class', 'node-label');

      labelEnter.append('text')
        .attr('text-anchor', 'middle')
        .attr('dy', -14)
        .text(d => d.hostname || 'Unknown host');

      labelEnter.append('text')
        .attr('class', 'node-label-ip')
        .attr('text-anchor', 'middle')
        .attr('dy', 2)
        .text(d => d.label);

      labelSel = labelEnter.merge(labelSel);

      // Update simulation graph
      simulation.nodes(nodes);
      linkForce.links(links);

      simulation.alpha(0.6).restart();
    };

    let loading = false;

    const setLoadingState = (state) => {
      loading = state;
    };

    const friendlyInterfaceName = (iface) => {
      const name = typeof iface === 'string' ? iface : iface?.name;
      const address = typeof iface === 'string' ? null : (iface?.address || iface?.ipv4);

      if (!name) return '(default capture)';

      const lower = name.toLowerCase();
      let prefix = '';

      if (lower === 'lo' || lower === 'lo0') {
        prefix = 'Loopback';
      } else if (/^(en|eth|em|p[0-9]+p)/.test(lower)) {
        prefix = 'Ethernet';
      } else if (/^(wl|wlan)/.test(lower)) {
        prefix = 'Wi‑Fi';
      } else if (/^(br|bridge)/.test(lower)) {
        prefix = 'Bridge';
      } else if (/^vmnet|^vboxnet|^virbr/.test(lower)) {
        prefix = 'Virtual adapter';
      }

      const base = prefix ? `${prefix} (${name})` : name;
      return address ? `${base} — ${address}` : base;
    };

    const loadInterfaces = async () => {
      if (!ifaceSelect) return;
      try {
        const res = await fetch('/api/network_interfaces');
        const data = await res.json();

        ifaceSelect.innerHTML = '';

        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = friendlyInterfaceName('');
        ifaceSelect.appendChild(defaultOpt);

        (data.interfaces || []).forEach(iface => {
          const name = typeof iface === 'string' ? iface : iface?.name;
          if (!name) return;

          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = friendlyInterfaceName(iface);
          if (data.active && data.active === name) {
            opt.selected = true;
          }
          ifaceSelect.appendChild(opt);
        });
      } catch (err) {
        console.error('Failed to load interfaces', err);
      }
    };

    const resetGraph = () => {
      nodes = [];
      links = [];
      knownNodeIds.clear();

      nodeLayer.selectAll('*').remove();
      linkLayer.selectAll('*').remove();
      labelLayer.selectAll('*').remove();

      nodeSel  = nodeLayer.selectAll('circle');
      linkSel  = linkLayer.selectAll('line');
      labelSel = labelLayer.selectAll('g');

      simulation.nodes(nodes);
      linkForce.links(links);
      simulation.alpha(0.1).restart();
    };

    const update = async () => {
      if (loading) return;
      setLoadingState(true);
      statusEl.textContent = 'Loading topology…';
      try {
        const response = await fetch('/api/network_topology');
        const data = await response.json();

        const updatedAt = new Date();
        const status = `Graph built from last ${data.metadata?.window_seconds || {{ window_seconds }}}s of local traffic. Updated ${updatedAt.toLocaleTimeString()}.`;
        statusEl.textContent = status;

        updateSummary(data);
        renderTable(data.links || []);

        // Re-render when new nodes appear or existing ones disappear
        const serverNodeIds = new Set((data.nodes || []).map(n => n.id));
        let hasNewNode = false;
        for (const id of serverNodeIds) {
          if (!knownNodeIds.has(id)) {
            hasNewNode = true;
          }
        }

        const hasRemovedNode = [...knownNodeIds].some(id => !serverNodeIds.has(id));
        knownNodeIds = serverNodeIds;

        if (hasNewNode || hasRemovedNode) {
          renderGraph(data);
        }
      } catch (err) {
        statusEl.textContent = 'Unable to load topology data';
        console.error(err);
      } finally {
        setLoadingState(false);
      }
    };

    if (ifaceSelect) {
      ifaceSelect.addEventListener('change', async () => {
        const value = ifaceSelect.value;
        try {
          await fetch('/api/network_interface', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ interface: value || null }),
          });

          // Reset graph state on interface change
          resetGraph();
          update();
        } catch (err) {
          console.error('Failed to switch interface', err);
        }
      });
    }

    const resetButton = document.getElementById('resetTopologyBtn');
    if (resetButton) {
      resetButton.addEventListener('click', () => {
        resetGraph();
        statusEl.textContent = 'Topology reset. Waiting for new traffic…';
      });
    }

    update();
    loadInterfaces();
    setInterval(update, 1000);
  })();
</script>
{% endblock %}
