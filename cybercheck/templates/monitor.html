{% extends "layout.html" %}

{% block body %}
<div class="page-header">
  <div>
    <h1 class="h2 mb-2">Live network monitor</h1>
    <p class="page-subtitle mb-0">Inspect packet activity on the selected network interface, review protocol mix and receive alerts when suspicious surges are detected. Keep this view open while you exercise the network to watch flows appear in real time.</p>
  </div>
  <div class="text-end small text-muted" id="monitorStatus"></div>
</div>

<div class="row g-4" id="monitorMetrics">
  <div class="col-xl-3 col-md-6">
    <div class="metric-card">
      <span class="metric-label">Total packets</span>
      <span class="metric-value" data-field="totals.packets">—</span>
      <span class="metric-subtext">Captured since monitor start</span>
    </div>
  </div>
  <div class="col-xl-3 col-md-6">
    <div class="metric-card">
      <span class="metric-label">Throughput</span>
      <span class="metric-value" data-field="window.rate">—</span>
      <span class="metric-subtext">Packets per second ({{ window_seconds }}s window)</span>
    </div>
  </div>
  <div class="col-xl-3 col-md-6">
    <div class="metric-card">
      <span class="metric-label">Data observed</span>
      <span class="metric-value" data-field="totals.bytes">—</span>
      <span class="metric-subtext">Approximate bytes captured</span>
    </div>
  </div>
  <div class="col-xl-3 col-md-6">
    <div class="metric-card">
      <span class="metric-label">Uptime</span>
      <span class="metric-value" data-field="uptime">—</span>
      <span class="metric-subtext">Monitor runtime</span>
    </div>
  </div>
</div>

<div class="row g-4 mt-1" id="monitorSecondaryMetrics">
  <div class="col-xl-4 col-md-6">
    <div class="metric-card">
      <span class="metric-label">Window data</span>
      <span class="metric-value" data-field="window.bytes">—</span>
      <span class="metric-subtext">Bytes captured in the rolling window</span>
    </div>
  </div>
  <div class="col-xl-4 col-md-6">
    <div class="metric-card">
      <span class="metric-label">Bandwidth</span>
      <span class="metric-value" data-field="window.bandwidth">—</span>
      <span class="metric-subtext">Approximate bytes per second</span>
    </div>
  </div>
  <div class="col-xl-4 col-md-6">
    <div class="metric-card">
      <span class="metric-label">Unique hosts</span>
      <span class="metric-value" data-field="unique_hosts">—</span>
      <span class="metric-subtext">Sources and destinations seen</span>
    </div>
  </div>
</div>

<div class="row g-4 mt-1">
  <div class="col-12">
    <div class="card shadow-sm border-0">
      <div class="card-header bg-white border-0 pt-4 pb-3">
        <div class="d-flex flex-wrap justify-content-between align-items-center gap-3">
          <div>
            <h2 class="h5 mb-0">Ingress vs egress</h2>
            <p class="text-muted small mb-0">Live bytes per second observed across the monitored interface.</p>
          </div>
          <span class="badge rounded-pill text-bg-light text-dark">1s buckets</span>
        </div>
      </div>
      <div class="card-body">
        <div class="bandwidth-chart">
          <canvas id="bandwidthChart" aria-label="Bandwidth over time" role="img"></canvas>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="row g-4 mt-1">
  <div class="col-lg-7">
    <div class="card shadow-sm border-0 h-100">
      <div class="card-header bg-white border-0 pt-4 pb-3">
        <h2 class="h5 mb-0">Protocol mix</h2>
      </div>
      <div class="card-body">
        <div class="protocol-list" id="protocolList"></div>
        <p class="text-muted small mb-0">Totals update every few seconds to reflect the live capture.</p>
      </div>
    </div>
  </div>
  <div class="col-lg-5">
    <div class="card shadow-sm border-0 h-100">
      <div class="card-header bg-white border-0 pt-4 pb-3">
        <h2 class="h5 mb-0">Top talkers</h2>
      </div>
      <div class="card-body">
        <div class="row g-4">
          <div class="col-12">
            <h3 class="h6 text-uppercase text-muted fw-semibold">Sources</h3>
            <ul class="monitor-list" id="topSources"></ul>
          </div>
          <div class="col-12">
            <h3 class="h6 text-uppercase text-muted fw-semibold">Destinations</h3>
            <ul class="monitor-list" id="topDestinations"></ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="row g-4 mt-1">
  <div class="col-lg-6">
    <div class="card shadow-sm border-0 h-100">
      <div class="card-header bg-white border-0 pt-4 pb-3">
        <h2 class="h5 mb-0">Top destination ports</h2>
      </div>
      <div class="card-body">
        <div class="row g-4">
          <div class="col-12">
            <h3 class="h6 text-uppercase text-muted fw-semibold">All captures</h3>
            <ul class="monitor-list" id="topPorts"></ul>
          </div>
          <div class="col-12">
            <h3 class="h6 text-uppercase text-muted fw-semibold">Active window</h3>
            <ul class="monitor-list" id="activePorts"></ul>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="col-lg-6">
    <div class="card shadow-sm border-0 h-100">
      <div class="card-header bg-white border-0 pt-4 pb-3">
        <h2 class="h5 mb-0">Fan-out watch</h2>
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-sm align-middle monitor-table">
            <thead>
              <tr>
                <th scope="col">Source</th>
                <th scope="col" class="text-center">Unique destinations</th>
                <th scope="col" class="text-end">Packets</th>
              </tr>
            </thead>
            <tbody id="fanOutTable"></tbody>
          </table>
        </div>
        <p class="text-muted small mb-0">Borrowing ideas from community packet monitors, this section surfaces hosts that quickly
          speak to many peers – a common sign of reconnaissance or worm traffic.</p>
      </div>
    </div>
  </div>
</div>

<div class="row g-4 mt-1">
  <div class="col-xl-6">
    <div class="card shadow-sm border-0 h-100">
      <div class="card-header bg-white border-0 pt-4 pb-3 d-flex justify-content-between align-items-center">
        <h2 class="h5 mb-0">Alert stream</h2>
        <span class="badge rounded-pill text-bg-secondary" id="alertCount">0 alerts</span>
      </div>
      <div class="card-body">
        <div class="alert-feed" id="alertFeed"></div>
        <p class="text-muted small mb-0">Burst detections help spot abnormal conditions like DDoS style floods generated with Scapy.</p>
      </div>
    </div>
  </div>
  <div class="col-xl-6">
    <div class="card shadow-sm border-0 h-100">
      <div class="card-header bg-white border-0 pt-4 pb-3 d-flex justify-content-between align-items-center">
        <h2 class="h5 mb-0">Recent packets</h2>
        <span class="badge rounded-pill text-bg-secondary" id="recentCount">0 shown</span>
      </div>
      <div class="card-body">
        <div class="table-responsive">
          <table class="table table-sm align-middle monitor-table">
            <thead>
              <tr>
                <th scope="col">Time (UTC)</th>
                <th scope="col">Src → Dst</th>
                <th scope="col">Proto</th>
                <th scope="col" class="text-end">Bytes</th>
              </tr>
            </thead>
            <tbody id="recentPackets"></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<template id="alertTemplate">
  <div class="alert monitor-alert" role="alert">
    <div class="d-flex justify-content-between align-items-start">
      <div>
        <strong class="alert-badge me-2"></strong>
        <span class="alert-message"></span>
      </div>
      <span class="alert-time small text-muted"></span>
    </div>
  </div>
</template>

<script>
  (() => {
    const statusEl = document.getElementById('monitorStatus');
    const protocolList = document.getElementById('protocolList');
    const topSources = document.getElementById('topSources');
    const topDestinations = document.getElementById('topDestinations');
    const topPorts = document.getElementById('topPorts');
    const activePorts = document.getElementById('activePorts');
    const fanOutTable = document.getElementById('fanOutTable');
    const alertFeed = document.getElementById('alertFeed');
    const recentTable = document.getElementById('recentPackets');
    const alertCount = document.getElementById('alertCount');
    const recentCount = document.getElementById('recentCount');
    const alertTemplate = document.getElementById('alertTemplate');
    const bandwidthChartEl = document.getElementById('bandwidthChart');
    const bandwidthCtx = bandwidthChartEl ? bandwidthChartEl.getContext('2d') : null;

    const metricFields = document.querySelectorAll('[data-field]');

    function formatNumber(value) {
      if (value === null || value === undefined || Number.isNaN(value)) {
        return '—';
      }
      if (value >= 1_000_000) {
        return (value / 1_000_000).toFixed(1).replace(/\.0$/, '') + 'M';
      }
      if (value >= 1_000) {
        return (value / 1_000).toFixed(1).replace(/\.0$/, '') + 'K';
      }
      return String(Math.round(value));
    }

    function formatBytes(bytes) {
      if (!bytes || bytes <= 0) return '0 B';
      const units = ['B', 'KB', 'MB', 'GB'];
      let idx = 0;
      let value = bytes;
      while (value >= 1024 && idx < units.length - 1) {
        value /= 1024;
        idx++;
      }
      return value.toFixed(value >= 10 || idx === 0 ? 0 : 1) + ' ' + units[idx];
    }

    function formatUptime(seconds) {
      if (!seconds || seconds < 0) return '—';
      const mins = Math.floor(seconds / 60);
      const hrs = Math.floor(mins / 60);
      const days = Math.floor(hrs / 24);
      if (days) return `${days}d ${hrs % 24}h`;
      if (hrs) return `${hrs}h ${mins % 60}m`;
      if (mins) return `${mins}m ${(seconds % 60).toFixed(0)}s`;
      return `${seconds.toFixed(0)}s`;
    }

    function setMetric(field, value) {
      let display = value;
      if (field === 'totals.bytes' || field === 'window.bytes') {
        display = formatBytes(value);
      } else if (field === 'uptime') {
        display = formatUptime(value);
      } else if (field === 'window.rate') {
        display = value ? value.toFixed(1) : '0.0';
      } else if (field === 'window.bandwidth') {
        if (!value || value <= 0) {
          display = '0 B/s';
        } else {
          const perSec = formatBytes(value);
          display = `${perSec}/s`;
        }
      } else {
        display = formatNumber(value);
      }
      return display;
    }

    function renderList(container, entries) {
      container.innerHTML = '';
      if (!entries || !entries.length) {
        const li = document.createElement('li');
        li.className = 'text-muted small';
        li.textContent = 'No data captured yet.';
        container.appendChild(li);
        return;
      }
      entries.forEach(item => {
        const li = document.createElement('li');
        li.innerHTML = `<span class="fw-semibold">${item.key}</span><span class="badge text-bg-primary rounded-pill">${item.count}</span>`;
        container.appendChild(li);
      });
    }

    function renderProtocols(protocols) {
      protocolList.innerHTML = '';
      const entries = Object.entries(protocols || {});
      if (!entries.length) {
        protocolList.innerHTML = '<p class="text-muted small mb-0">Waiting for packets…</p>';
        return;
      }
      entries.sort((a, b) => b[1] - a[1]);
      entries.forEach(([proto, count]) => {
        const pct = metricData.totals && metricData.totals.packets ? Math.round((count / metricData.totals.packets) * 100) : 0;
        const row = document.createElement('div');
        row.className = 'protocol-row';
        row.innerHTML = `
          <div class="protocol-label">${proto}</div>
          <div class="protocol-meter">
            <span class="protocol-meter-bar" style="width:${Math.min(pct, 100)}%"></span>
          </div>
          <div class="protocol-count">${formatNumber(count)}<small class="text-muted"> (${pct}%)</small></div>`;
        protocolList.appendChild(row);
      });
    }

    function renderAlerts(alerts) {
      alertFeed.innerHTML = '';
      if (!alerts || !alerts.length) {
        alertFeed.innerHTML = '<p class="text-muted small mb-0">No alerts yet. Generate some traffic to populate this feed.</p>';
        alertCount.textContent = '0 alerts';
        return;
      }
      alertCount.textContent = `${alerts.length} alert${alerts.length === 1 ? '' : 's'}`;
      alerts.forEach(entry => {
        const clone = alertTemplate.content.firstElementChild.cloneNode(true);
        clone.classList.add(`alert-${entry.severity || 'warning'}`);
        clone.querySelector('.alert-badge').textContent = entry.severity ? entry.severity.toUpperCase() : 'WARN';
        clone.querySelector('.alert-message').textContent = entry.message;
        clone.querySelector('.alert-time').textContent = new Date(entry.time).toLocaleTimeString('en-GB', { hour12: false });
        alertFeed.appendChild(clone);
      });
    }

    function renderFanOut(entries) {
      fanOutTable.innerHTML = '';
      if (!entries || !entries.length) {
        fanOutTable.innerHTML = '<tr><td colspan="3" class="text-muted small">No high fan-out sources detected in the current window.</td></tr>';
        return;
      }
      entries.forEach(entry => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${entry.source}</td>
          <td class="text-center">${formatNumber(entry.unique_destinations)}</td>
          <td class="text-end">${formatNumber(entry.packets)}</td>`;
        fanOutTable.appendChild(tr);
      });
    }

    function renderRecent(packets) {
      recentTable.innerHTML = '';
      if (!packets || !packets.length) {
        recentTable.innerHTML = '<tr><td colspan="4" class="text-muted small">No packets captured yet.</td></tr>';
        recentCount.textContent = '0 shown';
        return;
      }
      recentCount.textContent = `${packets.length} shown`;
      packets.forEach(pkt => {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${new Date(pkt.time).toLocaleTimeString('en-GB', { hour12: false })}</td>
          <td><span class="fw-semibold">${pkt.src}</span><span class="text-muted"> → </span><span class="fw-semibold">${pkt.dst}</span></td>
          <td><span class="badge text-bg-light text-dark">${pkt.protocol}</span></td>
          <td class="text-end">${formatNumber(pkt.size)}</td>`;
        recentTable.appendChild(tr);
      });
    }

    function drawLine(ctx, data, color, xStart, yScale, step) {
      if (!data.length) return;
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      data.forEach((value, idx) => {
        const x = xStart + (idx * step);
        const y = yScale(value);
        if (idx === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
    }

    function drawLegend(ctx, label, color, x, y) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y - 10, 14, 4);
      ctx.fillStyle = '#495057';
      ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      ctx.fillText(label, x + 20, y);
    }

    function renderBandwidth(history) {
      if (!bandwidthChartEl || !bandwidthCtx) return;
      const entries = (history || []).slice(-90);
      const inbound = entries.map(entry => Math.max(0, Math.round(entry.inbound || 0)));
      const outbound = entries.map(entry => Math.max(0, Math.round(entry.outbound || 0)));
      const maxValue = Math.max(1, ...inbound, ...outbound);

      const width = bandwidthChartEl.clientWidth || 600;
      const height = bandwidthChartEl.clientHeight || 280;
      bandwidthChartEl.width = width;
      bandwidthChartEl.height = height;
      const ctx = bandwidthCtx;
      ctx.clearRect(0, 0, width, height);

      if (!entries.length) {
        ctx.fillStyle = '#adb5bd';
        ctx.font = '14px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        ctx.fillText('Waiting for packets…', 16, height / 2);
        return;
      }

      const padding = { top: 28, right: 24, bottom: 28, left: 60 };
      const chartWidth = Math.max(10, width - padding.left - padding.right);
      const chartHeight = Math.max(10, height - padding.top - padding.bottom);
      const pointCount = entries.length;
      const step = pointCount > 1 ? chartWidth / (pointCount - 1) : 0;
      const yScale = (value) => padding.top + chartHeight - ((value / maxValue) * chartHeight);

      ctx.strokeStyle = '#e9ecef';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.rect(padding.left, padding.top, chartWidth, chartHeight);
      ctx.stroke();

      ctx.fillStyle = '#6c757d';
      ctx.font = '12px system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
      const ticks = 4;
      for (let i = 0; i <= ticks; i++) {
        const ratio = i / ticks;
        const value = maxValue * (1 - ratio);
        const y = padding.top + (chartHeight * ratio);
        ctx.strokeStyle = 'rgba(0,0,0,0.05)';
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(padding.left + chartWidth, y);
        ctx.stroke();
        ctx.fillStyle = '#6c757d';
        ctx.fillText(`${formatBytes(value)}/s`, 4, y + 4);
      }

      drawLine(ctx, inbound, '#10b981', padding.left, yScale, step);
      drawLine(ctx, outbound, '#3b82f6', padding.left, yScale, step);

      ctx.textAlign = 'center';
      ctx.fillStyle = '#6c757d';
      const firstLabel = new Date(entries[0].ts * 1000).toLocaleTimeString('en-GB', { hour12: false });
      const lastLabel = new Date(entries[entries.length - 1].ts * 1000).toLocaleTimeString('en-GB', { hour12: false });
      ctx.fillText(firstLabel, padding.left, height - 6);
      if (entries.length > 1) {
        ctx.fillText(lastLabel, padding.left + chartWidth, height - 6);
      }
      ctx.textAlign = 'left';
      drawLegend(ctx, 'Incoming', '#10b981', padding.left, 18);
      drawLegend(ctx, 'Outgoing', '#3b82f6', padding.left + 140, 18);
    }

    const metricData = {};

    function assignValue(path, value) {
      const segments = path.split('.');
      let target = metricData;
      segments.slice(0, -1).forEach(segment => {
        target = target[segment] = target[segment] || {};
      });
      const lastIndex = segments.length - 1;
      target[segments[lastIndex]] = value;
    }

    function updateMetrics(snapshot) {
      metricFields.forEach(fieldEl => {
        const path = fieldEl.getAttribute('data-field');
        const segments = path.split('.');
        let value = snapshot;
        for (const segment of segments) {
          value = value ? value[segment] : undefined;
        }
        assignValue(path, value);
        fieldEl.textContent = setMetric(path, value);
      });
    }

    function refresh() {
      fetch("{{ url_for('api_network_snapshot') }}")
        .then(resp => resp.json())
        .then(snapshot => {
          if (snapshot.error) {
            statusEl.innerHTML = `<span class="badge text-bg-danger">Monitor error</span> ${snapshot.error}`;
          } else {
            const meta = [];
            if (snapshot.running) meta.push('<span class="badge text-bg-success">Sniffing</span>');
            if (snapshot.interface) meta.push(`<span class="badge text-bg-dark">${snapshot.interface}</span>`);
            if (snapshot.filter) meta.push(`<span class="badge text-bg-secondary">${snapshot.filter}</span>`);
            statusEl.innerHTML = meta.join(' ');
          }

          updateMetrics(snapshot);
          renderProtocols(snapshot.protocols);
          renderList(topSources, snapshot.top_sources);
          renderList(topDestinations, snapshot.top_destinations);
          renderList(topPorts, snapshot.top_ports);
          renderList(activePorts, snapshot.window ? snapshot.window.port_activity : []);
          renderFanOut(snapshot.fan_out);
          renderAlerts(snapshot.alert_log);
          renderRecent(snapshot.recent_packets);
          renderBandwidth(snapshot.bandwidth_history);
        })
        .catch(err => {
          statusEl.innerHTML = `<span class="badge text-bg-danger">Error</span> ${err}`;
        });
    }

    refresh();
    setInterval(refresh, 3000);
  })();
</script>
{% endblock %}

